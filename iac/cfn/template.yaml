AWSTemplateFormatVersion: '2010-09-09'
Description: 'AWS Portfolio Project - Static Website with CloudFront and Optional EC2 API'

Parameters:
  BucketName:
    Type: String
    Description: 'S3 Bucket name for static website (must be globally unique)'
    AllowedPattern: '^[a-z0-9-]+$'
    ConstraintDescription: 'Bucket name must contain only lowercase letters, numbers, and hyphens'
  
  DomainName:
    Type: String
    Description: 'Custom domain name (optional)'
    Default: ''
  
  CertificateArn:
    Type: String
    Description: 'SSL Certificate ARN for custom domain (optional)'
    Default: ''
  
  InstanceType:
    Type: String
    Description: 'EC2 Instance type for API server'
    Default: 't3.micro'
    AllowedValues:
      - t3.micro
      - t3.small
      - t3.medium

Conditions:
  HasCustomDomain: !Not [!Equals [!Ref DomainName, '']]
  HasCertificate: !Not [!Equals [!Ref CertificateArn, '']]

Resources:
  # S3 Bucket for Static Website
  WebsiteBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref BucketName
      PublicAccessBlockConfiguration:
        BlockPublicAcls: false
        BlockPublicPolicy: false
        IgnorePublicAcls: false
        RestrictPublicBuckets: false
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: index.html

  # S3 Bucket Policy
  WebsiteBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref WebsiteBucket
      PolicyDocument:
        Statement:
          - Effect: Allow
            Principal: '*'
            Action: 's3:GetObject'
            Resource: !Sub '${WebsiteBucket}/*'

  # CloudFront Origin Access Control
  OriginAccessControl:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub '${AWS::StackName}-OAC'
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  # CloudFront Distribution
  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Origins:
          - Id: S3Origin
            DomainName: !GetAtt WebsiteBucket.RegionalDomainName
            S3OriginConfig:
              OriginAccessIdentity: ''
            OriginAccessControlId: !Ref OriginAccessControl
        Enabled: true
        DefaultRootObject: index.html
        Comment: !Sub 'CloudFront distribution for ${AWS::StackName}'
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad  # Managed-CachingOptimized
          OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf  # Managed-CORS-S3Origin
        PriceClass: PriceClass_100
        Aliases: !If [HasCustomDomain, [!Ref DomainName], !Ref 'AWS::NoValue']]
        ViewerCertificate: !If
          - HasCertificate
          - AcmCertificateArn: !Ref CertificateArn
            SslSupportMethod: sni-only
            MinimumProtocolVersion: TLSv1.2_2021
          - CloudFrontDefaultCertificate: true

  # EC2 Security Group
  ApiSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: 'Security group for API server'
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
          Description: 'HTTP access for API'
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: 'HTTPS access for API'
        # SSH 存取限制 - 只允許特定 IP 範圍
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 10.0.0.0/8
          Description: 'SSH access from private networks only'
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
          Description: 'All outbound traffic'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-API-SG'

  # IAM Role for EC2 Instance
  ApiInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
      Policies:
        - PolicyName: S3ReadOnlyAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource: 
                  - !Sub '${WebsiteBucket}/*'
                  - !GetAtt WebsiteBucket.Arn
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-API-Role'

  # Instance Profile
  ApiInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref ApiInstanceRole

  # EC2 Instance for API
  ApiInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: ami-0c02fb55956c7d316  # Amazon Linux 2 AMI
      InstanceType: !Ref InstanceType
      SecurityGroupIds:
        - !Ref ApiSecurityGroup
      IamInstanceProfile: !Ref ApiInstanceProfile
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          yum update -y
          yum install -y python3 pip curl
          
          # 安裝 CloudWatch Agent
          yum install -y amazon-cloudwatch-agent
          
          # 設定防火牆
          systemctl enable firewalld
          systemctl start firewalld
          firewall-cmd --permanent --add-port=80/tcp
          firewall-cmd --permanent --add-port=443/tcp
          firewall-cmd --reload
          
          # 建立應用程式目錄
          mkdir -p /var/www/api
          cd /var/www/api
          
          # 建立安全的 Flask 應用程式
          cat > app.py << 'EOF'
          from flask import Flask, jsonify, request
          from flask_cors import CORS
          import html
          import re
          import os
          from datetime import datetime
          import logging
          
          app = Flask(__name__)
          CORS(app, origins=['https://your-domain.com'])
          
          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger(__name__)
          
          msgs = []
          
          def sanitize_input(text):
              if not text or not isinstance(text, str):
                  return ""
              if len(text) > 500:
                  text = text[:500]
              text = html.escape(text)
              text = re.sub(r'[^\w\s\u4e00-\u9fff.,!?@#$%^&*()_+-=]', '', text)
              return text.strip()
          
          @app.route("/api/guestbook", methods=['GET'])
          def list_msgs():
              try:
                  return jsonify({"messages": msgs, "count": len(msgs)}), 200
              except Exception as e:
                  logger.error(f"Error retrieving messages: {e}")
                  return jsonify({"error": "Internal server error"}), 500
          
          @app.route("/api/guestbook", methods=['POST'])
          def add_msg():
              try:
                  data = request.get_json(silent=True) or {}
                  msg_content = sanitize_input(data.get("msg", ""))
                  if not msg_content:
                      return jsonify({"error": "Message content is required"}), 400
                  
                  new_msg = {
                      "msg": msg_content,
                      "from": "web",
                      "timestamp": datetime.utcnow().isoformat(),
                      "id": len(msgs) + 1
                  }
                  
                  msgs.append(new_msg)
                  if len(msgs) > 1000:
                      msgs.pop(0)
                  
                  logger.info(f"New message added: {msg_content[:50]}...")
                  return jsonify({"ok": True, "message": new_msg}), 201
                  
              except Exception as e:
                  logger.error(f"Error adding message: {e}")
                  return jsonify({"error": "Internal server error"}), 500
          
          @app.route("/")
          def health():
              return {"ok": True, "timestamp": datetime.utcnow().isoformat()}, 200
          
          if __name__ == "__main__":
              app.run(host="0.0.0.0", port=80, debug=False)
          EOF
          
          # 安裝 Python 依賴
          pip3 install flask flask-cors gunicorn
          
          # 建立 systemd 服務
          cat > /etc/systemd/system/api.service << 'EOF'
          [Unit]
          Description=Portfolio API
          After=network.target
          
          [Service]
          Type=simple
          User=ec2-user
          WorkingDirectory=/var/www/api
          ExecStart=/usr/local/bin/gunicorn --bind 0.0.0.0:80 --workers 2 --timeout 30 app:app
          Restart=always
          RestartSec=10
          
          [Install]
          WantedBy=multi-user.target
          EOF
          
          # 啟動服務
          systemctl enable api.service
          systemctl start api.service
          
          # 設定日誌輪轉
          cat > /etc/logrotate.d/api << 'EOF'
          /var/log/api.log {
              daily
              missingok
              rotate 7
              compress
              delaycompress
              notifempty
              create 644 ec2-user ec2-user
          }
          EOF
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-API'

Outputs:
  WebsiteBucketName:
    Description: 'S3 Bucket name for the website'
    Value: !Ref WebsiteBucket
    Export:
      Name: !Sub '${AWS::StackName}-WebsiteBucket'
  
  CloudFrontDistributionId:
    Description: 'CloudFront Distribution ID'
    Value: !Ref CloudFrontDistribution
    Export:
      Name: !Sub '${AWS::StackName}-CloudFrontDistribution'
  
  WebsiteURL:
    Description: 'Website URL'
    Value: !If
      - HasCustomDomain
      - !Sub 'https://${DomainName}'
      - !Sub 'https://${CloudFrontDistribution.DomainName}'
    Export:
      Name: !Sub '${AWS::StackName}-WebsiteURL'
  
  ApiEndpoint:
    Description: 'API Server Endpoint'
    Value: !Sub 'http://${ApiInstance.PublicIp}/api/guestbook'
    Export:
      Name: !Sub '${AWS::StackName}-ApiEndpoint'