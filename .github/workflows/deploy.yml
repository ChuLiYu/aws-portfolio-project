name: Deploy Portfolio to AWS

on:
  workflow_dispatch:
#   push:
#     branches: [ main ]
#   pull_request:
#     branches: [ main ]

# env:
#   AWS_REGION: us-east-1
#   STACK_NAME: portfolio-stack

# jobs:
#   # 測試和建置作業
#   test-and-build:
#     runs-on: ubuntu-latest

#     steps:
#     - name: Checkout code
#       uses: actions/checkout@v4

#     - name: Set up Python
#       uses: actions/setup-python@v4
#       with:
#         python-version: '3.11'

#     - name: Install dependencies
#       run: |
#         cd api
#         pip install -r requirements.txt
#         pip install pytest pytest-cov flake8

#     - name: Lint with flake8
#       run: |
#         cd api
#         flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
#         flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

#     - name: Test with pytest
#       run: |
#         cd api
#         python -m pytest --cov=app --cov-report=xml

#     - name: Build Docker image
#       run: |
#         cd api
#         docker build -t portfolio-api:latest .

#     - name: Test Docker container
#       run: |
#         cd api
#         docker run -d --name test-api -p 5000:80 portfolio-api:latest
#         sleep 10
#         curl -f http://localhost:5000/ || exit 1
#         docker stop test-api
#         docker rm test-api

#   # 部署到 AWS
#   deploy:
#     needs: test-and-build
#     runs-on: ubuntu-latest
#     if: github.ref == 'refs/heads/main'

#     steps:
#     - name: Checkout code
#       uses: actions/checkout@v4

#     - name: Configure AWS credentials
#       uses: aws-actions/configure-aws-credentials@v4
#       with:
#         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#         aws-region: ${{ env.AWS_REGION }}

#     - name: Deploy CloudFormation Stack
#       run: |
#         # 檢查堆疊是否存在
#         if aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
#           echo "Stack exists, updating..."
#           aws cloudformation update-stack \
#             --stack-name ${{ env.STACK_NAME }} \
#             --template-body file://iac/cfn/template.yaml \
#             --parameters ParameterKey=BucketName,ParameterValue=${{ secrets.S3_BUCKET_NAME }} \
#             --capabilities CAPABILITY_IAM \
#             --region ${{ env.AWS_REGION }}
#         else
#           echo "Stack does not exist, creating..."
#           aws cloudformation create-stack \
#             --stack-name ${{ env.STACK_NAME }} \
#             --template-body file://iac/cfn/template.yaml \
#             --parameters ParameterKey=BucketName,ParameterValue=${{ secrets.S3_BUCKET_NAME }} \
#             --capabilities CAPABILITY_IAM \
#             --region ${{ env.AWS_REGION }}
#         fi

#     - name: Wait for stack deployment
#       run: |
#         aws cloudformation wait stack-create-complete \
#           --stack-name ${{ env.STACK_NAME }} \
#           --region ${{ env.AWS_REGION }} || \
#         aws cloudformation wait stack-update-complete \
#           --stack-name ${{ env.STACK_NAME }} \
#           --region ${{ env.AWS_REGION }}

#     - name: Get stack outputs
#       id: get-outputs
#       run: |
#         OUTPUTS=$(aws cloudformation describe-stacks \
#           --stack-name ${{ env.STACK_NAME }} \
#           --region ${{ env.AWS_REGION }} \
#           --query 'Stacks[0].Outputs')
#         echo "outputs=$OUTPUTS" >> $GITHUB_OUTPUT

#     - name: Upload frontend to S3
#       run: |
#         BUCKET_NAME=$(aws cloudformation describe-stacks \
#           --stack-name ${{ env.STACK_NAME }} \
#           --region ${{ env.AWS_REGION }} \
#           --query 'Stacks[0].Outputs[?OutputKey==`WebsiteBucketName`].OutputValue' \
#           --output text)

#         echo "Uploading frontend to bucket: $BUCKET_NAME"
#         aws s3 sync frontend/ s3://$BUCKET_NAME/ \
#           --delete \
#           --cache-control "max-age=31536000" \
#           --exclude "*.html" \
#           --exclude "*.css"

#         # HTML 和 CSS 檔案使用較短的快取時間
#         aws s3 sync frontend/ s3://$BUCKET_NAME/ \
#           --cache-control "max-age=3600" \
#           --include "*.html" \
#           --include "*.css"

#     - name: Invalidate CloudFront cache
#       run: |
#         DISTRIBUTION_ID=$(aws cloudformation describe-stacks \
#           --stack-name ${{ env.STACK_NAME }} \
#           --region ${{ env.AWS_REGION }} \
#           --query 'Stacks[0].Outputs[?OutputKey==`CloudFrontDistributionId`].OutputValue' \
#           --output text)

#         echo "Invalidating CloudFront distribution: $DISTRIBUTION_ID"
#         aws cloudfront create-invalidation \
#           --distribution-id $DISTRIBUTION_ID \
#           --paths "/*"

#     - name: Deploy API to EC2
#       run: |
#         # 取得 EC2 實例 IP
#         INSTANCE_IP=$(aws cloudformation describe-stacks \
#           --stack-name ${{ env.STACK_NAME }} \
#           --region ${{ env.AWS_REGION }} \
#           --query 'Stacks[0].Outputs[?OutputKey==`ApiEndpoint`].OutputValue' \
#           --output text | sed 's|http://||' | sed 's|/api/guestbook||')

#         echo "Deploying API to EC2 instance: $INSTANCE_IP"

#         # 建立部署腳本
#         cat > deploy-api.sh << 'EOF'
#         #!/bin/bash
#         set -e

#         # 更新系統
#         sudo yum update -y

#         # 安裝 Docker
#         sudo yum install -y docker
#         sudo systemctl start docker
#         sudo systemctl enable docker
#         sudo usermod -a -G docker ec2-user

#         # 建立應用程式目錄
#         sudo mkdir -p /var/www/api
#         sudo chown ec2-user:ec2-user /var/www/api
#         cd /var/www/api

#         # 停止現有服務
#         sudo systemctl stop api.service || true

#         # 建立新的應用程式檔案
#         cat > app.py << 'APPEOF'
#         from flask import Flask, jsonify, request
#         from flask_cors import CORS
#         import html
#         import re
#         import os
#         from datetime import datetime
#         import logging
#         from collections import defaultdict, deque
#         import time

#         app = Flask(__name__)

#         # CORS 設定
#         allowed_origins = os.getenv("ALLOWED_ORIGINS", "http://localhost:8080").split(",")
#         CORS(
#             app,
#             origins=allowed_origins,
#             methods=["GET", "POST"],
#             allow_headers=["Content-Type"],
#         )

#         logging.basicConfig(level=logging.INFO)
#         logger = logging.getLogger(__name__)

#         msgs = []

#         # 速率限制設定
#         RATE_LIMIT_PER_MINUTE = int(os.getenv("RATE_LIMIT_PER_MINUTE", "60"))
#         RATE_LIMIT_PER_HOUR = int(os.getenv("RATE_LIMIT_PER_HOUR", "1000"))

#         rate_limiter = defaultdict(lambda: {"minute": deque(), "hour": deque()})

#         def check_rate_limit(ip_address):
#             current_time = time.time()
#             minute_window = current_time - 60
#             hour_window = current_time - 3600

#             while (
#                 rate_limiter[ip_address]["minute"]
#                 and rate_limiter[ip_address]["minute"][0] < minute_window
#             ):
#                 rate_limiter[ip_address]["minute"].popleft()

#             while (
#                 rate_limiter[ip_address]["hour"]
#                 and rate_limiter[ip_address]["hour"][0] < hour_window
#             ):
#                 rate_limiter[ip_address]["hour"].popleft()

#             if len(rate_limiter[ip_address]["minute"]) >= RATE_LIMIT_PER_MINUTE:
#                 return False, "Rate limit exceeded: too many requests per minute"

#             if len(rate_limiter[ip_address]["hour"]) >= RATE_LIMIT_PER_HOUR:
#                 return False, "Rate limit exceeded: too many requests per hour"

#             rate_limiter[ip_address]["minute"].append(current_time)
#             rate_limiter[ip_address]["hour"].append(current_time)

#             return True, None

#         def sanitize_input(text):
#             if not text or not isinstance(text, str):
#                 return ""
#             if len(text) > 500:
#                 text = text[:500]
#             text = html.escape(text)
#             text = re.sub(r"[^\w\s\u4e00-\u9fff.,!?@#$%^&*()_+-=]", "", text)
#             return text.strip()

#         @app.get("/api/guestbook")
#         def list_msgs():
#             try:
#                 client_ip = request.environ.get("HTTP_X_FORWARDED_FOR", request.remote_addr)
#                 if client_ip:
#                     client_ip = client_ip.split(",")[0].strip()

#                 allowed, error_msg = check_rate_limit(client_ip)
#                 if not allowed:
#                     logger.warning(f"Rate limit exceeded for IP: {client_ip}")
#                     return jsonify({"error": error_msg}), 429

#                 return jsonify({"messages": msgs, "count": len(msgs)}), 200
#             except Exception as e:
#                 logger.error(f"Error retrieving messages: {e}")
#                 return jsonify({"error": "Internal server error"}), 500

#         @app.post("/api/guestbook")
#         def add_msg():
#             try:
#                 client_ip = request.environ.get("HTTP_X_FORWARDED_FOR", request.remote_addr)
#                 if client_ip:
#                     client_ip = client_ip.split(",")[0].strip()

#                 allowed, error_msg = check_rate_limit(client_ip)
#                 if not allowed:
#                     logger.warning(f"Rate limit exceeded for IP: {client_ip}")
#                     return jsonify({"error": error_msg}), 429

#                 data = request.get_json(silent=True) or {}
#                 msg_content = sanitize_input(data.get("msg", ""))
#                 if not msg_content:
#                     return jsonify({"error": "Message content is required"}), 400

#                 new_msg = {
#                     "msg": msg_content,
#                     "from": "web",
#                     "timestamp": datetime.utcnow().isoformat(),
#                     "id": len(msgs) + 1,
#                 }

#                 msgs.append(new_msg)
#                 if len(msgs) > 1000:
#                     msgs.pop(0)

#                 logger.info(f"New message added from IP {client_ip}: {msg_content[:50]}...")
#                 return jsonify({"ok": True, "message": new_msg}), 201

#             except Exception as e:
#                 logger.error(f"Error adding message: {e}")
#                 return jsonify({"error": "Internal server error"}), 500

#         @app.get("/")
#         def health():
#             return {"ok": True, "timestamp": datetime.utcnow().isoformat()}, 200

#         if __name__ == "__main__":
#             debug_mode = os.getenv("FLASK_DEBUG", "False").lower() == "true"
#             port = int(os.getenv("FLASK_PORT", 80))

#             if debug_mode:
#                 logger.warning("Running in DEBUG mode - not suitable for production!")
#                 app.run(host="0.0.0.0", port=port, debug=True)
#             else:
#                 logger.info("Starting production server...")
#                 app.run(host="0.0.0.0", port=port, debug=False)
#         APPEOF

#         # 安裝 Python 依賴
#         pip3 install flask flask-cors gunicorn

#         # 更新 systemd 服務
#         sudo tee /etc/systemd/system/api.service > /dev/null << 'SERVICEEOF'
#         [Unit]
#         Description=Portfolio API
#         After=network.target

#         [Service]
#         Type=simple
#         User=ec2-user
#         WorkingDirectory=/var/www/api
#         ExecStart=/usr/local/bin/gunicorn --bind 0.0.0.0:80 --workers 2 --timeout 30 app:app
#         Restart=always
#         RestartSec=10
#         Environment=FLASK_ENV=production
#         Environment=FLASK_DEBUG=False

#         [Install]
#         WantedBy=multi-user.target
#         SERVICEEOF

#         # 重新載入並啟動服務
#         sudo systemctl daemon-reload
#         sudo systemctl enable api.service
#         sudo systemctl start api.service

#         # 檢查服務狀態
#         sudo systemctl status api.service --no-pager
#         EOF

#         # 複製部署腳本到 EC2
#         scp -o StrictHostKeyChecking=no deploy-api.sh ec2-user@$INSTANCE_IP:/tmp/

#         # 執行部署腳本
#         ssh -o StrictHostKeyChecking=no ec2-user@$INSTANCE_IP 'chmod +x /tmp/deploy-api.sh && /tmp/deploy-api.sh'

#     - name: Verify deployment
#       run: |
#         # 等待服務啟動
#         sleep 30

#         # 取得網站 URL
#         WEBSITE_URL=$(aws cloudformation describe-stacks \
#           --stack-name ${{ env.STACK_NAME }} \
#           --region ${{ env.AWS_REGION }} \
#           --query 'Stacks[0].Outputs[?OutputKey==`WebsiteURL`].OutputValue' \
#           --output text)

#         # 取得 API 端點
#         API_ENDPOINT=$(aws cloudformation describe-stacks \
#           --stack-name ${{ env.STACK_NAME }} \
#           --region ${{ env.AWS_REGION }} \
#           --query 'Stacks[0].Outputs[?OutputKey==`ApiEndpoint`].OutputValue' \
#           --output text)

#         echo "Website URL: $WEBSITE_URL"
#         echo "API Endpoint: $API_ENDPOINT"

#         # 測試 API 健康檢查
#         curl -f $API_ENDPOINT/ || exit 1

#         # 測試網站
#         curl -f $WEBSITE_URL || exit 1

#     - name: Comment deployment status
#       if: always()
#       uses: actions/github-script@v7
#       with:
#         script: |
#           const outputs = `${{ steps.get-outputs.outputs.outputs }}`;
#           const parsed = JSON.parse(outputs);

#           let comment = '## 🚀 Deployment Status\n\n';

#           if ('${{ job.status }}' === 'success') {
#             comment += '✅ **Deployment Successful!**\n\n';
#             comment += '### 🌐 Access URLs:\n';

#             parsed.forEach(output => {
#               if (output.OutputKey === 'WebsiteURL') {
#                 comment += `- **Website**: ${output.OutputValue}\n`;
#               } else if (output.OutputKey === 'ApiEndpoint') {
#                 comment += `- **API**: ${output.OutputValue}\n`;
#               }
#             });
#           } else {
#             comment += '❌ **Deployment Failed**\n\n';
#             comment += 'Please check the logs for details.';
#           }

#           github.rest.issues.createComment({
#             issue_number: context.issue.number,
#             owner: context.repo.owner,
#             repo: context.repo.repo,
#             body: comment
#           });
